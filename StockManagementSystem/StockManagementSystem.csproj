<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
     <TargetFrameworks>netcoreapp2.2</TargetFrameworks>
      <!--Set this parameter to true to get the dlls copied from the NuGet cache to the output of your project-->
      <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
      <Version>1.0.1</Version>
  </PropertyGroup>

  <ItemGroup>
      <Compile Remove="Migrations\20181226114021_AddCategoryAndNotificationTable.cs" />
      <Compile Remove="Migrations\20181228083905_AddPushNotificationStoresTable.cs" />
      <Compile Remove="Migrations\20181231074401_InitialCreate.cs" />
      <Compile Remove="Migrations\20181231074401_InitialCreate.Designer.cs" />
      <Compile Remove="Migrations\20190102041345_InitialCreate.cs" />
      <Compile Remove="Migrations\20190102041345_InitialCreate.Designer.cs" />
      <Compile Remove="Migrations\20190102044342_InitialCreate.cs" />
      <Compile Remove="Migrations\20190102044342_InitialCreate.Designer.cs" />
      <Compile Remove="Migrations\20190109041941_UpdatePushNotificationTable.cs" />
      <Compile Remove="Migrations\20190109041941_UpdatePushNotificationTable.Designer.cs" />
      <Compile Remove="Migrations\20190110012221_UpdatePushNotificationField.cs" />
      <Compile Remove="Migrations\20190110012221_UpdatePushNotificationField.Designer.cs" />
      <Compile Remove="Migrations\20190118064530_AddFormatSettingTable.cs" />
      <Compile Remove="Migrations\20190123021215_AddTable.cs" />
      <Compile Remove="Migrations\20190123021215_AddTable.Designer.cs" />
      <Compile Remove="Models\Devices\DeviceViewModel.cs" />
      <Compile Remove="Models\PushNotifications\AddNotificationViewModel.cs" />
      <Compile Remove="Models\PushNotifications\EditNotificationViewModel.cs" />
      <Compile Remove="Models\PushNotifications\NotificationViewModel.cs" />
      <Compile Remove="Models\PushNotifications\PushNotificationViewModel.cs" />
      <None Update="Views\sitemap.config">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      </None>
  </ItemGroup>

  <ItemGroup>
      <PackageReference Include="Bower" Version="1.3.11" />
      <PackageReference Include="Geocoding.Core" Version="4.0.1" />
      <PackageReference Include="Geocoding.Google" Version="4.0.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\StockManagementSystem.Core\StockManagementSystem.Core.csproj" />
    <ProjectReference Include="..\StockManagementSystem.Data\StockManagementSystem.Data.csproj" />
    <ProjectReference Include="..\StockManagementSystem.Services\StockManagementSystem.Services.csproj" />
    <ProjectReference Include="..\StockManagementSystem.Web\StockManagementSystem.Web.csproj" />
  </ItemGroup>

  <PropertyGroup>
    <!--The common language runtime (CLR) supports two types of garbage collection:
    workstation garbage collection, which is available on all systems, and server garbage collection,
    which is available on multiprocessor systems.
    <None Include="wwwroot\lib\datatables.net\js\jquery.dataTables.min.js" />
    <None Include="wwwroot\lib\datatables.net\Readme.md" />
      
    For single-processor computers, the default workstation garbage collection should be the fastest option.
    Either workstation or server can be used for two-processor computers.
    Server garbage collection should be the fastest option for more than two processors.
      
    More details about GC you can see here: https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals-->
    <ServerGarbageCollection>false</ServerGarbageCollection>
    <!--In workstation or server garbage collection, you can enable concurrent garbage collection,
    which enables threads to run concurrently with a dedicated thread that performs the garbage
    collection for most of the duration of the collection.
      
    Concurrent garbage collection enables interactive applications to be more responsive by
    minimizing pauses for a collection. Managed threads can continue to run most of the time while
    the concurrent garbage collection thread is running. This results in shorter pauses while
    a garbage collection is occurring.
      
    To improve performance when several processes are running, disable concurrent garbage collection.
      
    More details here: https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals#concurrent-garbage-collection-->
    <ConcurrentGarbageCollection>false</ConcurrentGarbageCollection>
  </PropertyGroup>

</Project>
